import CategoryTheory.Set

class Category.{v} (Œ± : Type u) : Type (max u v) where
  Hom : Œ± ‚Üí Œ± ‚Üí Sort v
  id (A : Œ±) : Hom A A
  comp {A B C : Œ±} : Hom B C ‚Üí Hom A B ‚Üí Hom A C
  id_comp' {A B : Œ±} (f : Hom A B) : comp (id B) f = f
  comp_id' {A B : Œ±} (f : Hom A B) : comp f (id A) = f
  assoc' {A B C D : Œ±} (h : Hom C D) (g : Hom B C) (f : Hom A B) :
    comp (comp h g) f = comp h (comp g f)

namespace Category

scoped infixr:10 " ‚ü∂ " => Category.Hom
scoped infixr:90 " ‚àò " => Category.comp
scoped notation "ùüô" => Category.id

variable {Œ± Œ≤ Œ≥ Œ¥ : Type _} {A B C D : Œ±}
  [Category Œ±] [Category Œ≤] [Category Œ≥] [Category Œ¥]

@[simp]
theorem comp_id (f : A ‚ü∂ B) :
    f ‚àò ùüô A = f :=
  comp_id' f

@[simp]
theorem id_comp (f : A ‚ü∂ B) :
    ùüô B ‚àò f = f :=
  id_comp' f

@[simp]
theorem assoc (h : C ‚ü∂ D) (g : B ‚ü∂ C) (f : A ‚ü∂ B) :
    (h ‚àò g) ‚àò f = h ‚àò g ‚àò f :=
  assoc' h g f

theorem whisker_eq (h : B ‚ü∂ C) {f g : A ‚ü∂ B} (w : f = g) :
    h ‚àò f = h ‚àò g :=
  by rw [w]

theorem eq_whisker {f g : B ‚ü∂ C} (w : f = g) (h : A ‚ü∂ B) :
    f ‚àò h = g ‚àò h :=
  by rw [w]

instance : Category (Type _) where
  Hom Œ± Œ≤ := Œ± ‚Üí Œ≤
  id _ := fun x => x
  comp f g := fun x => f (g x)
  id_comp' _ := rfl
  comp_id' _ := rfl
  assoc' _ _ _ := rfl

@[simp]
theorem Type.id (Œ± : Type _) :
    ùüô Œ± = fun x => x :=
  rfl

@[simp]
theorem Type.comp (g : Œ≤ ‚ü∂ Œ≥) (f : Œ± ‚ü∂ Œ≤) :
    Category.comp g f = Function.comp g f :=
  rfl

structure Opposite (Œ± : Sort u) :=
  unop : Œ±

namespace Opposite

scoped notation:max Œ± "·µí·µñ" => Opposite Œ±

def op (x : Œ±) : Œ±·µí·µñ := ‚ü®x‚ü©

instance [Category Œ±] : Category Œ±·µí·µñ where
  Hom Œ± Œ≤ := unop Œ≤ ‚ü∂ unop Œ±
  id Œ± := ùüô (unop Œ±)
  comp f g := g ‚àò f
  id_comp' f := comp_id f
  comp_id' f := id_comp f
  assoc' h g f := (assoc f g h).symm

end Opposite

open Opposite

@[ext]
structure Functor (Œ± : Type u‚ÇÅ) (Œ≤ : Type u‚ÇÇ) [Category.{v‚ÇÅ} Œ±] [Category.{v‚ÇÇ} Œ≤] :
    Type (max u‚ÇÅ u‚ÇÇ v‚ÇÅ v‚ÇÇ) where
  obj : Œ± ‚Üí Œ≤
  map {A B : Œ±} : (A ‚ü∂ B) ‚Üí (obj A ‚ü∂ obj B)
  map_id {A : Œ±} : map (ùüô A) = ùüô (obj A)
  map_comp {A B C : Œ±} (g : B ‚ü∂ C) (f : A ‚ü∂ B) : map (g ‚àò f) = map g ‚àò map f

attribute [simp] Functor.map_id Functor.map_comp

scoped infixr:26 " ‚•§ " => Functor

/-- The covariant powerset functor. -/
def Power : Type u ‚•§ Type u where
  obj A := Set A
  map := Set.image
  map_id := by
    intro A
    funext S
    exact Set.image_id S
  map_comp := by
    intro A B C g f
    funext S
    exact Set.image_comp g f S

@[simp]
theorem Power_obj : Power.obj Œ± = Set Œ± := rfl

@[simp]
theorem Power_map : Power.map f = Set.image f := rfl

/-- The contravariant powerset functor. -/
def CoPower : (Type u)·µí·µñ ‚•§ Type u where
  obj A := Set (unop A)
  map := Set.preimage
  map_id := rfl
  map_comp _ _ := rfl

def Functor.id (Œ± : Type _) [Category Œ±] : Œ± ‚•§ Œ± where
  obj A := A
  map f := f
  map_id := by simp
  map_comp := by simp

scoped notation "ùü≠" => Functor.id

@[simp]
theorem Functor.id_obj : (ùü≠ Œ±).obj A = A := rfl

@[simp]
theorem Functor.id_map : (ùü≠ Œ±).map f = f := rfl

def Functor.comp (G : Œ≤ ‚•§ Œ≥) (F : Œ± ‚•§ Œ≤) : Œ± ‚•§ Œ≥ where
  obj A := G.obj (F.obj A)
  map f := G.map (F.map f)
  map_id := by simp
  map_comp := by simp

scoped infixr:80 " ‚óå " => Functor.comp

@[simp]
theorem Functor.comp_obj (G : Œ≤ ‚•§ Œ≥) (F : Œ± ‚•§ Œ≤) :
    (G ‚óå F).obj A = G.obj (F.obj A) :=
  rfl

@[simp]
theorem Functor.comp_map (G : Œ≤ ‚•§ Œ≥) (F : Œ± ‚•§ Œ≤) :
    (G ‚óå F).map f = G.map (F.map f) :=
  rfl

@[simp]
theorem Functor.id_comp (F : Œ± ‚•§ Œ≤) : ùü≠ Œ≤ ‚óå F = F :=
  by aesop

@[simp]
theorem Functor.comp_id (F : Œ± ‚•§ Œ≤) : F ‚óå ùü≠ Œ± = F :=
  by aesop

@[simp]
theorem Functor.comp_assoc (H : Œ≥ ‚•§ Œ¥) (G : Œ≤ ‚•§ Œ≥) (F : Œ± ‚•§ Œ≤) :
    (H ‚óå G) ‚óå F = H ‚óå G ‚óå F :=
  by aesop

structure Bundled (c : Type u ‚Üí Type v) : Type max (u + 1) v where
  Œ± : Type u
  str : c Œ± := by infer_instance

namespace Bundled

attribute [coe] Œ±

set_option checkBinderAnnotations false in
def of {c : Type u ‚Üí Type v} (Œ± : Type u) [str : c Œ±] : Bundled c :=
  ‚ü®Œ±, str‚ü©

instance coeSort : CoeSort (Bundled c) (Type u) :=
  ‚ü®Bundled.Œ±‚ü©

theorem coe_mk (Œ±) (str) : (@Bundled.mk c Œ± str : Type u) = Œ± :=
  rfl

def map (f : ‚àÄ {Œ±}, c Œ± ‚Üí d Œ±) (b : Bundled c) : Bundled d :=
  ‚ü®b, f b.str‚ü©

end Bundled

abbrev Cat.{v, u} := Bundled Category.{v, u}

instance : Coe Cat.{v, u} (Type u) where
  coe := Bundled.Œ±

instance (Œ± : Cat.{v, u}) : Category.{v, u} Œ± :=
  Œ±.str

instance : Category (Cat.{v, u}) where
  Hom Œ± Œ≤ := Œ± ‚•§ Œ≤
  id Œ± := ùü≠ Œ±
  comp G F := G ‚óå F
  id_comp' := by simp
  comp_id' := by simp
  assoc' := by simp

def Functor.opposite (F : Œ± ‚•§ Œ≤) : Œ±·µí·µñ ‚•§ Œ≤·µí·µñ where
  obj A := op (F.obj A.unop)
  map f := F.map f
  map_id := F.map_id
  map_comp g f := F.map_comp f g

@[simp]
theorem Functor.opposite_obj (F : Œ± ‚•§ Œ≤) (A : Œ±·µí·µñ) :
    F.opposite.obj A = op (F.obj A.unop) :=
  rfl

@[simp]
theorem Functor.opposite_map (F : Œ± ‚•§ Œ≤) {A B : Œ±·µí·µñ} (f : A ‚ü∂ B) :
    F.opposite.map f = F.map f :=
  rfl

@[simp]
theorem Functor.opposite_id :
    (ùü≠ Œ±).opposite = ùü≠ Œ±·µí·µñ :=
  rfl

def Op : Cat ‚•§ Cat where
  obj Œ± := Bundled.of Œ±·µí·µñ
  map f := f.opposite
  map_id := rfl
  map_comp _ _ := rfl

structure Congruence (Œ± : Type _) [Category Œ±] where
  rel (A B : Œ±) : (A ‚ü∂ B) ‚Üí (A ‚ü∂ B) ‚Üí Prop
  equivalence (A B : Œ±) : Equivalence (rel A B)
  rel_whisker {A B C : Œ±} (f g : B ‚ü∂ C) (h : A ‚ü∂ B) (fg : rel B C f g) :
    rel A C (f ‚àò h) (g ‚àò h)
  whisker_rel {A B C : Œ±} (f : B ‚ü∂ C) (g h : A ‚ü∂ B) (fg : rel A B g h) :
    rel A C (f ‚àò g) (f ‚àò h)

def Congruence.setoid (r : Congruence Œ±) (A B : Œ±) : Setoid (A ‚ü∂ B) where
  r := r.rel A B
  iseqv := r.equivalence A B

structure HomQuotient (r : Congruence Œ±) where
  unquot : Œ±

def HomQuotient.quotObj (r : Congruence Œ±) (A : Œ±) :
    HomQuotient r :=
  ‚ü®A‚ü©

def HomQuotient.quotHom (r : Congruence Œ±) {A B : Œ±} (f : A ‚ü∂ B) :
    Quotient (r.setoid A B) :=
  Quotient.mk _ f

theorem HomQuotient.comp_rel {r : Congruence Œ±} {A B C : HomQuotient r}
    (f‚ÇÅ : B.unquot ‚ü∂ C.unquot) (g‚ÇÅ : A.unquot ‚ü∂ B.unquot)
    (f‚ÇÇ : B.unquot ‚ü∂ C.unquot) (g‚ÇÇ : A.unquot ‚ü∂ B.unquot)
    (hf : r.rel _ _ f‚ÇÅ f‚ÇÇ) (hg : r.rel _ _ g‚ÇÅ g‚ÇÇ) :
    Quotient.mk (Congruence.setoid r A.unquot C.unquot) (f‚ÇÅ ‚àò g‚ÇÅ) =
    Quotient.mk (Congruence.setoid r A.unquot C.unquot) (f‚ÇÇ ‚àò g‚ÇÇ) := by
  have h‚ÇÅ := r.whisker_rel f‚ÇÅ g‚ÇÅ g‚ÇÇ hg
  have h‚ÇÇ := r.rel_whisker f‚ÇÅ f‚ÇÇ g‚ÇÇ hf
  exact Quotient.sound ((r.equivalence _ _).trans h‚ÇÅ h‚ÇÇ)

@[simp]
theorem _root_.Quotient.lift‚ÇÇ_mk {Œ± Œ≤ Œ≥ : Sort _} {_ : Setoid Œ±} {_ : Setoid Œ≤}
    (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥)
    (h : ‚àÄ (a‚ÇÅ : Œ±) (a‚ÇÇ : Œ≤) (b‚ÇÅ : Œ±) (b‚ÇÇ : Œ≤), a‚ÇÅ ‚âà b‚ÇÅ ‚Üí a‚ÇÇ ‚âà b‚ÇÇ ‚Üí f a‚ÇÅ a‚ÇÇ = f b‚ÇÅ b‚ÇÇ)
    (a : Œ±) (b : Œ≤) :
    Quotient.lift‚ÇÇ f h (Quotient.mk _ a) (Quotient.mk _ b) = f a b :=
  rfl

instance (r : Congruence Œ±) : Category (HomQuotient r) where
  Hom A B := Quotient (r.setoid A.unquot B.unquot)
  id A := Quotient.mk _ (ùüô A.unquot)
  comp := Quotient.lift‚ÇÇ (fun f g => Quotient.mk _ (f ‚àò g)) HomQuotient.comp_rel
  id_comp' := by
    intro A B f
    refine Quotient.inductionOn f ?_
    simp
  comp_id' := by
    intro A B f
    refine Quotient.inductionOn f ?_
    simp
  assoc' := by
    intro A B C D f g h
    refine Quotient.inductionOn‚ÇÉ f g h ?_
    simp

@[simp]
theorem HomQuotient.quotHom_eq_iff (r : Congruence Œ±)
    {A B : Œ±} (f g : A ‚ü∂ B) :
    quotHom r f = quotHom r g ‚Üî r.rel A B f g := by
  constructor
  ¬∑ intro h
    exact Quotient.exact h
  ¬∑ intro h
    exact Quotient.sound h

@[elab_as_elim]
theorem HomQuotient.inductionOn {r : Congruence Œ±}
    {A B : HomQuotient r} {motive : (A ‚ü∂ B) ‚Üí Prop}
    (f : A ‚ü∂ B) (h : ‚àÄ f : A.unquot ‚ü∂ B.unquot, motive (quotHom r f)) :
    motive f :=
  Quotient.inductionOn f h

/-- The quotient map into a quotient category. -/
def HomQuotient.quotient (r : Congruence Œ±) : Œ± ‚•§ HomQuotient r where
  obj A := quotObj r A
  map f := quotHom r f
  map_id := by aesop
  map_comp := by aesop

@[simp]
theorem HomQuotient.quotient_obj (r : Congruence Œ±) (A : Œ±) :
    (quotient r).obj A = quotObj r A :=
  rfl

@[simp]
theorem HomQuotient.quotient_map (r : Congruence Œ±) {A B : Œ±} (f : A ‚ü∂ B) :
    (quotient r).map f = quotHom r f :=
  rfl

@[ext]
structure NatTrans {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [Category.{v‚ÇÅ} Œ±] [Category.{v‚ÇÇ} Œ≤]
    (F G : Œ± ‚•§ Œ≤) : Type (max u‚ÇÅ v‚ÇÇ) where
  app (A : Œ±) : F.obj A ‚ü∂ G.obj A
  naturality {A B : Œ±} (f : A ‚ü∂ B) :
    app B ‚àò F.map f = G.map f ‚àò app A

attribute [simp] NatTrans.naturality

def NatTrans.id (F : Œ± ‚•§ Œ≤) : NatTrans F F where
  app A := ùüô (F.obj A)
  naturality f := by simp

@[simp]
theorem NatTrans.id_app (F : Œ± ‚•§ Œ≤) (A : Œ±) :
    (NatTrans.id F).app A = ùüô (F.obj A) :=
  rfl

def NatTrans.comp {F G H : Œ± ‚•§ Œ≤} (Œ∑‚ÇÅ : NatTrans G H) (Œ∑‚ÇÇ : NatTrans F G) :
    NatTrans F H where
  app A := Œ∑‚ÇÅ.app A ‚àò Œ∑‚ÇÇ.app A
  naturality {A B} f := by
    dsimp only
    rw [assoc, naturality, ‚Üê assoc, naturality, assoc]

@[simp]
theorem NatTrans.comp_app {F G H : Œ± ‚•§ Œ≤}
    (Œ∑‚ÇÅ : NatTrans G H) (Œ∑‚ÇÇ : NatTrans F G) (A : Œ±) :
    (Œ∑‚ÇÅ.comp Œ∑‚ÇÇ).app A = Œ∑‚ÇÅ.app A ‚àò Œ∑‚ÇÇ.app A :=
  rfl

theorem NatTrans.id_comp {F G : Œ± ‚•§ Œ≤} (Œ∑ : NatTrans F G) :
    (NatTrans.id G).comp Œ∑ = Œ∑ :=
  by ext; simp

theorem NatTrans.comp_id {F G : Œ± ‚•§ Œ≤} (Œ∑ : NatTrans F G) :
    Œ∑.comp (NatTrans.id F) = Œ∑ :=
  by ext; simp

theorem NatTrans.comp_assoc {F G H K : Œ± ‚•§ Œ≤}
    (Œ∑‚ÇÅ : NatTrans H K) (Œ∑‚ÇÇ : NatTrans G H) (Œ∑‚ÇÉ : NatTrans F G) :
    (Œ∑‚ÇÅ.comp Œ∑‚ÇÇ).comp Œ∑‚ÇÉ = Œ∑‚ÇÅ.comp (Œ∑‚ÇÇ.comp Œ∑‚ÇÉ) :=
  by ext; simp

def NatTrans.power : NatTrans (ùü≠ (Type u)) Power.{u} where
  app Œ± x := ({x} : Set Œ±)
  naturality f := by funext; simp

instance (Œ± : Type u‚ÇÅ) (Œ≤ : Type u‚ÇÇ) [Category.{v‚ÇÅ, u‚ÇÅ} Œ±] [Category.{v‚ÇÇ, u‚ÇÇ} Œ≤] :
    Category (Œ± ‚•§ Œ≤) where
  Hom := NatTrans
  id := NatTrans.id
  comp := NatTrans.comp
  id_comp' := NatTrans.id_comp
  comp_id' := NatTrans.comp_id
  assoc' := NatTrans.comp_assoc

@[simp]
theorem Functor.Hom {F G : Œ± ‚•§ Œ≤} : (F ‚ü∂ G) = NatTrans F G := rfl

@[simp]
theorem Functor.id' {F : Œ± ‚•§ Œ≤} : ùüô F = NatTrans.id F := rfl

@[simp]
theorem Functor.comp' {F G H : Œ± ‚•§ Œ≤} {Œ∑‚ÇÅ : G ‚ü∂ H} {Œ∑‚ÇÇ : F ‚ü∂ G} :
    Œ∑‚ÇÅ ‚àò Œ∑‚ÇÇ = NatTrans.comp Œ∑‚ÇÅ Œ∑‚ÇÇ :=
  rfl

structure Iso (A B : Œ±) where
  toHom : A ‚ü∂ B
  invHom : B ‚ü∂ A
  toHom_invHom : toHom ‚àò invHom = ùüô B
  invHom_toHom : invHom ‚àò toHom = ùüô A

infixl:25 " ‚âÉ " => Iso

instance : Coe (A ‚âÉ B) (A ‚ü∂ B) where
  coe := Iso.toHom

def Iso.refl (A : Œ±) : A ‚âÉ A where
  toHom := ùüô A
  invHom := ùüô A
  toHom_invHom := by simp
  invHom_toHom := by simp

def Iso.symm (f : A ‚âÉ B) : B ‚âÉ A where
  toHom := f.invHom
  invHom := f.toHom
  toHom_invHom := f.invHom_toHom
  invHom_toHom := f.toHom_invHom

@[simp]
theorem Iso.comp_symm (f : A ‚âÉ B) :
    f ‚àò (f.symm : B ‚ü∂ A) = ùüô B :=
  f.toHom_invHom

@[simp]
theorem Iso.symm_comp (f : A ‚âÉ B) :
    f.symm ‚àò (f : A ‚ü∂ B) = ùüô A :=
  f.invHom_toHom

def Faithful (F : Œ± ‚•§ Œ≤) : Prop :=
  ‚àÄ A B : Œ±, ‚àÄ f g : A ‚ü∂ B, F.map f = F.map g ‚Üí f = g

def Full (F : Œ± ‚•§ Œ≤) : Prop :=
  ‚àÄ A B : Œ±, ‚àÄ g : F.obj A ‚ü∂ F.obj B, ‚àÉ f : A ‚ü∂ B, F.map f = g

def EssSurjective (F : Œ± ‚•§ Œ≤) : Prop :=
  ‚àÄ B : Œ≤, Nonempty ((A : Œ±) √ó' (F.obj A ‚âÉ B))

theorem HomQuotient.quotient_full (r : Congruence Œ±) :
    Full (quotient r) := by
  intro A B g
  refine Quotient.inductionOn g ?_
  intro g
  exact ‚ü®g, rfl‚ü©

theorem HomQuotient.quotient_essSurjective (r : Congruence Œ±) :
    EssSurjective (quotient r) := by
  intro B
  exact ‚ü®‚ü®B.unquot, Iso.refl _‚ü©‚ü©

end Category
